#《链接 装载与库》读书笔记

##Chapter 2 - 编译和链接

* 编译器的处理流程：
	* 预编译：处理预编译指令（#define #if etc...） 展开宏定义 删除注释
	* 编译：将源代码转换为**汇编代码**
		*  词法分析：分离源代码中的词
		*  语法分析：对词进行展开成表达式树
		*  语义分析：对表达式树进行检查（类型检查，合法性检查 etc...）
		*  源码优化：对可以预处理的源码进行优化
    * 汇编：汇编器将汇编代码转变为机器指令，输出**目标文件**
    * 链接：由于有多个文件可能相互引用不在本文件内的变量和函数，所以地址不能确认。需要链接器来最终确定这些变量和函数的地址
	    * 地址和空间分配
	    * 符号决议
	    * 重定位：将编译时不知道的变量和函数的目标地址修正填充

##Chapter 3 - 目标文件里有什么
* 目标文件其实是编译后的可执行文件，只是没有经过链接的过程，其中的有些符号和地址没有调整。
* 目标文件按信息的不同的属性，将其分为多个**"段"**（Segment）。
	* 源代码编译后的机器指令常被放在**代码段**内，代码段的常见名字有".code"或".text"
	* 全局变量和局部静态变量数据常放在**数据段**内，数据段的一般名字叫".data"
	* 未被初始化的全局变量和局部静态变量常放在一个叫".bss"的段内，因为它们都是0，不需要占据空间
	* 还有其它的段，如只读数据段，注释信息段，堆栈提示段，调试信息段
	* 将指令和数据分开成不同的段有以下好处：
		* 指令段只读，而数据段可读写，可以明确权限，防止指令段被无意改写
		* CPU的缓存通常设计为指令缓存和数据缓存分离，分成不同段有利于提高缓存命中率
		* 有多个程序副本时，指令只需存一份，可以共享；而数据段则是进程私有的。这样可以节省大量空间
* ELF文件格式也是一种**[“路径依赖”](http://wiki.mbalib.com/wiki/%E8%B7%AF%E5%BE%84%E4%BE%9D%E8%B5%96%E7%90%86%E8%AE%BA)**的表现，路径依赖类似惯性，影响着人类的生活和发展。
* 链接的本质是要把多个不同的目标文件相互“粘”到一起。目标文件的相互拼合的实际是目标文件之间对**函数和变量地址**的引用
* 每个函数和变量都有自己独特的名字，这样才能避免在链接中不同变量和函数之间的混淆
* 链接中，将函数和变量统称为**符号**（Symbol），函数名和变量名称为**符号名**（Symbol Name）
* 符号类型：
	* 定义在本目标文件的全局符号，可以被其它目标文件引用，如“main”函数
	* 在本目标文件引用的全局符号，但没有在本目标文件中定义，称为**外部符号**（External Symbol） ，如"printf"函数
	* 局部符号，行号信息，段名 等等
* 符号名可能会存在冲突，C++等高级语言增加了**名称空间**（Namespace），来解决这个问题
* `extern "C"`，C++编译器会将在`extern "C"`作用域内的代码当成C语言代码来处理
* 有时候如果要在C++中明确指定使用C语言中的符号，可以用以下方式：
```
#ifdef __cplusplus
extern "C" {
#endif

//如果是C++代码，则memset会在extern "C"内声明，声明的还是C语言的memset函数
void *memset (void *, int, size_t);

#ifdef __cplusplus
}
#endif
```
宏`__cplusplus`用于判断当前的编译单元是否为C++代码。
* 目标文件里面可能包含调试信息，调试信息巨大，程序发布时应去除之，可以用`strip`命令来去除调试信息

##Chapter 4 - 静态链接
* 链接器一般采用“两步链接”（Two-pass Linking）法：
	1. 空间与地址分配：扫描所有输入的目标文件，搜集各个段的信息，将所有符号定义和引用收集到一个全局符号表中
	2. 符号解析与重定位：利用上一步收集到的所有信息，读取输入段的数据，进行符号解析和重定位，调整代码中的地址
* 未进行地址分配时，程序代码使用的都是虚拟地址，起始地址都是从0开始，利用**地址偏移值**可以在实际分配地址时方便的计算出所有实际地址，此过程称为**重定位**
* 所有需要调整的指令地址，都需要放入一个**重定位表**（Relocation Table）中，重定位表其实是ELF文件中的一个段，以`.rel`作为前缀修饰
* 变量类型对于链接器是透明的，对于链接器来说可能出现多个符号定义类型不一致的情况：
	* 两个或以上的强符号类型不一致：非法
	* 一个强符号，其他的弱符号与之不一致：以强符号所占大小为准
	* 两个或以上的弱符号类型不一致：以最大的弱符号所占大小为准
	* 综上，一个弱符号的最终大小只有在读取所有输入目标文件后才能被确定
	* **未初始化的全局变量被视为弱符号**
* **静态库**：可简单视为**一组目标文件的集合（压缩包）**，方便使用，传输和管理组织
* 静态库里一个目标文件只包含一个函数的原因是，不会把其他无关的函数链接进输出结果中，可以尽量减少空间的浪费
* 在OSX下可以用`otool - tV`来模拟`objdump`命令，来查看一个ELF文件的段

##Chapter 6 - 可执行文件的装载与进程
* 装载：将程序从外部存储器读取到内存中
* 每个程序运行起来后都将拥有自己独立的**虚拟地址空间**，这个空间的大小受到计算机硬件的限制，如32位CPU只有4GB的寻址能力
* 程序所需的数据和指令不应全部载入到内存中，应该**动态装入**，即使用到哪个模块，再装入哪个模块，否则存放在外存中
* 页映射：将数据和指令按照页为单元划分为多个页。
* 如果内存中页已经不够了，有以下换页算法：
	* FIFO，先进先出，替换掉第一个被分配的内存页
	* LUR，最少使用，替换掉最少被访问的内存页
* 进程的建立过程：
	* 创建一个独立的虚拟地址空间
	* 读取可执行文件头，建立虚拟空间与可执行文件的映射关系：虚拟内存区域（VMA, Virtual Memory Area）
	* 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行
* 可执行文件内有很多段，如果一个段对应一页，则可能会造成空间的浪费。解决办法是：将读写可执行权限的段（Section）合并到一个段（Segment）中，然后映射一页
* 一个进程基本上划分为如下几个VMA：
	* 代码VMA，只读，可执行
	* 数据VMA，可读写，可执行
	* 堆VMA，可读写，可执行
	* 栈VMA，可读写，不可执行
*  每个可执行文件的开头几个字节用于确定文件的格式和类型，特别是开头的四个字节，被称为魔数

##Chapter 7 - 动态链接
* 静态链接的缺陷：
	* 空间浪费：有很多基础库，会被包含到不同的库中，每个库都有基础库的拷贝，造成大量的空间浪费
	* 难以更新，部署和发布：程序中一旦有模块更新，整个程序需要重新链接。任何位置有任何小改动，都需要发布整个程序